40 columns                              |
>>> Initializing formal.
class Foo {
  Foo(this  .  a, int  this  .  b,  final  this  .  c);
  Foo.optional([  this . a, int  this  . b   =  123  ]);
  Foo.named({ required   this . a, int  this  . b  = 123  });
}
<<<
class Foo {
  Foo(this.a, int this.b, final this.c);
  Foo.optional([
    this.a,
    int this.b = 123,
  ]);
  Foo.named({
    required this.a,
    int this.b = 123,
  });
}
>>> Function-typed initializing formal.
class Foo {
  Foo.function(this  .  a  (  int  x  ),  this  .  b  (  )  ?  );
  Foo.optional([ int  this . c() ,  this  .  d ( ) = x  ]);
  Foo.named({  required int  this . e()  ,  this  .  f ( ) = x });
}
<<<
class Foo {
  Foo.function(
    this.a(int x),
    this.b()?,
  );
  Foo.optional([
    int this.c(),
    this.d() = x,
  ]);
  Foo.named({
    required int this.e(),
    this.f() = x,
  });
}
>>> Super parameter.
class Foo {
  Foo(super  .  a, int  super  .  b,  final  super  .  c);
  Foo.optional([  super . a, int  super  . b   =  123  ]);
  Foo.named({ required   super . a, int  super  . b  = 123  });
}
<<<
class Foo {
  Foo(
    super.a,
    int super.b,
    final super.c,
  );
  Foo.optional([
    super.a,
    int super.b = 123,
  ]);
  Foo.named({
    required super.a,
    int super.b = 123,
  });
}
>>> Function-typed super parameter.
class Foo {
  Foo.function(super  .  a  (  int  x  ),  super  .  b  (  )  ?  );
  Foo.optional([ int  super . c() ,  super  .  d ( ) = x  ]);
  Foo.named({  required int  super . e()  ,  super  .  f ( ) = x });
}
<<<
class Foo {
  Foo.function(
    super.a(int x),
    super.b()?,
  );
  Foo.optional([
    int super.c(),
    super.d() = x,
  ]);
  Foo.named({
    required int super.e(),
    super.f() = x,
  });
}
>>> Covariant initializing formal.
### This isn't semantically valid Dart code, but it's syntactically valid so
### the formatter should handle it correctly.
class A {
  A(   covariant   this.foo);
}
<<<
class A {
  A(covariant this.foo);
}
>>> Private named initializing formal.
class A {
  A({this._x, required this._y, int? this._z});

  int? _x;
  int? _y;
  int? _z;
}
<<<
class A {
  A({
    this._x,
    required this._y,
    int? this._z,
  });

  int? _x;
  int? _y;
  int? _z;
}
>>> (experiment primary-constructors) Declaring normal parameters.
class C(var int x, final String y, var untyped, final another);
<<< 3.13
class C(
  var int x,
  final String y,
  var untyped,
  final another,
);
>>> (experiment primary-constructors) Declaring optional positional parameters.
class C([var int? x, final String? y, var untyped, final another]);
<<< 3.13
class C([
  var int? x,
  final String? y,
  var untyped,
  final another,
]);
>>> (experiment primary-constructors) Declaring optional named parameters.
class C({var int? x, final String? y, var untyped, final another});
<<< 3.13
class C({
  var int? x,
  final String? y,
  var untyped,
  final another,
});
>>> (experiment primary-constructors) Declaring required named parameters.
class C({required var int? x, required final String? y, required var untyped, required final another});
<<< 3.13
class C({
  required var int? x,
  required final String? y,
  required var untyped,
  required final another,
});
>>> (experiment primary-constructors) Declaring coviariant parameters.
class C(covariant var int? x, {required covariant var int z, covariant var String? a});
<<< 3.13
class C(
  covariant var int? x, {
  required covariant var int z,
  covariant var String? a,
});
>>> (experiment primary-constructors) Declaring parameter with default values.
class C1([var int x = 1, final String y = 's']);
class C2({var int x = 1, final String y = 's'});
<<< 3.13
class C1([
  var int x = 1,
  final String y = 's',
]);

class C2({
  var int x = 1,
  final String y = 's',
});
>>> (experiment primary-constructors) Declaring function-typed parameters.
class C(var int fn(), final callback(String s));
<<< 3.13
class C(
  var int fn(),
  final callback(String s),
);
