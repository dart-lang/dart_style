40 columns                              |
### Test how multiple block argument candidates are handled.
>>> Multiple function expressions prevent block formatting.
function(() { one; }, () { two; });
<<<
function(
  () {
    one;
  },
  () {
    two;
  },
);
>>> Empty and non-empty function expressions.
function(() {}, () { body; }, () {});
<<<
function(() {}, () {
  body;
}, () {});
>>> Function expression takes precedence over other kinds of block arguments.
### The function is block formatted but the other arguments aren't.
function([1, 2], () { body; }, {3, 4});
<<<
function([1, 2], () {
  body;
}, {3, 4});
>>> Multiple collections prevent block formatting.
function([element, element], {key: value});
<<<
function(
  [element, element],
  {key: value},
);
>>> Empty and non-empty collections.
function([], [element, element], <String>{});
<<<
function([], [
  element,
  element,
], <String>{});
>>> Multiple calls prevent block formatting.
function(inner(argument), new SomeClass(argument));
<<<
function(
  inner(argument),
  new SomeClass(argument),
);
>>> Empty and non-empty calls.
function(a(), inner(argument), const C());
<<<
function(a(), inner(
  argument,
), const C());
>>> Multiple switches prevent block formatting.
function(switch (a) { 1 => 2 }, switch (b) { 1 => 2 });
<<<
function(
  switch (a) { 1 => 2 },
  switch (b) { 1 => 2 },
);
>>> Empty and non-empty switches.
function(switch (a) {}, switch (b) { 1 => 2 }, switch (c) {});
<<<
function(switch (a) {}, switch (b) {
  1 => 2,
}, switch (c) {});
>>> Collection and multi-line string prevents block formatting.
function([element, element], '''multiple
lines''');
<<<
function(
  [element, element],
  '''multiple
lines''',
);
>>> Adjacent strings preceding a function expression doesn't prevent block formatting.
test('First adjacent string' 'second adjacent string'
'third adjacent string', () async {
  ;
});
<<<
test('First adjacent string'
    'second adjacent string'
    'third adjacent string', () async {
  ;
});
>>> Don't block format a function with a preceding adjacent string if it doesn't fit.
test('First adjacent string' 'second long adjacent string', () async {
  ;
});
<<<
test(
  'First adjacent string'
  'second long adjacent string',
  () async {
    ;
  },
);
>>> Don't block format adjacent strings preceding a non-function block argument.
test('First adjacent string'
    'second adjacent string'
    'third adjacent string', [
  element1,
  element2,
  element3,
  element4,
]);
<<<
test(
  'First adjacent string'
  'second adjacent string'
  'third adjacent string',
  [
    element1,
    element2,
    element3,
    element4,
  ],
);
>>> Other string arguments don't prevent block formatting.
test('First string line 1' 'first string line 2', () {
  ;
}, 'Another simple string');
<<<
test('First string line 1'
    'first string line 2', () {
  ;
}, 'Another simple string');
>>> Other adjacent string arguments prevent block formatting.
test('First string line 1' 'first string line 2', () {
  ;
}, 'Another adjacent' 'string argument');
<<<
test(
  'First string line 1'
      'first string line 2',
  () {
    ;
  },
  'Another adjacent'
      'string argument',
);